.Task.js
[source,javascript]
----
class Task {
  constructor(onSuccess, onError, onCancel) {
    this._pending = true;
    this._onSuccess = onSuccess;
    this._onError = onError;
    this._onCancel = onCancel;
    this.onAbort = null;
  }

  success(value) {
    if (this._pending) {
      const f = this._onSuccess;

      this._pending = false;
      this._onSuccess = null;
      this._onError = null;
      this._onCancel = null;
      this.onAbort = null;

      f(value);
    }
  }

  error(e) {
    if (this._pending) {
      const f = this._onError;

      this._pending = false;
      this._onSuccess = null;
      this._onError = null;
      this._onCancel = null;
      this.onAbort = null;

      f(e);
    }
  }

  cancel() {
    if (this._pending) {
      const f = this._onCancel;

      this._pending = false;
      this._onSuccess = null;
      this._onError = null;
      this._onCancel = null;
      this.onAbort = null;

      f();
    }
  }

  abort() {
    if (this._pending) {
      const f = this.onAbort;

      this._pending = false;
      this._onSuccess = null;
      this._onError = null;
      this.onAbort = null; // TODO what if somebody sets onAbort after the Task is aborted ?

      if (f !== null) {
        f();
      }
    }
  }
}


class Thread {
  constructor(task) {
    // 0 is pending
    // 1 is succeeded
    // 2 is errored
    // 3 is cancelled
    // 4 is aborted
    this._state = 0;
    this._value = null;
    this._listeners = [];

    this._task = run(task, (value) => {
      if (this._state === 0) {
        this._state = 1;
        this._value = value;

        // TODO this can be made a bit faster
        this._listeners["forEach"]((x) => {
          x.success(value);
        });

        this._listeners = null;
      }

    }, (e) => {
      if (this._state === 0) {
        this._state = 2;
        this._value = e;

        // TODO this can be made a bit faster
        this._listeners["forEach"]((x) => {
          x.error(e);
        });

        this._listeners = null;

        print_error(e);
      }

    }, () => {
      if (this._state === 0) {
        this._state = 3;

        // TODO this can be made a bit faster
        this._listeners["forEach"]((x) => {
          x.cancel();
        });

        this._listeners = null;
      }
    });
  }

  wait(task) {
    switch (this._state) {
    case 0:
      this._listeners["push"](task);

      task.onAbort = () => {
        // TODO replace with faster `remove` function
        const i = this._listeners["indexOf"](task);
        // TODO assert that `i` is never `-1` ?
        if (i !== -1) {
          this._listeners["splice"](i, 1);
        }
      };
      break;

    case 1:
      task.success(this._value);
      break;

    case 2:
      task.error(this._value);
      break;

    case 3:
      task.cancel();
      break;

    // TODO is this correct ?
    case 4:
      task.cancel();
      break;
    }
  }

  kill() {
    if (this._state === 0) {
      const t = this._task;

      this._state = 4;
      this._task = null;

      // TODO this can be made a bit faster
      this._listeners["forEach"]((x) => {
        x.cancel();
      });

      this._listeners = null;

      t.abort();
    }
  }
}


export const noop = () => {};

  // There's no standard way to cancel/abort a Promise
export const Task_from_Promise = (f) => (task) => {
  f()["then"]((x) => {
    task.success(x);
  }, (e) => {
    task.error(e);
  });
};

export const Promise_from_Task = (task) =>
  new Promise((resolve, reject) => {
    // TODO is cancellation correctly handled ?
    run(task, resolve, reject, reject);
  });

export const print_error = (e) => {
  console["error"](e["stack"]);
};

export const make_error = (s) => new Error(s);

export const run = (task, onSuccess, onError, onCancel) => {
  const t = new Task(onSuccess, onError, onCancel);
  task(t);
  return t;
};

export const run_root = (task) => {
  run(task, noop, print_error, noop);
};

// This can be implemented purely with `execute`,
// but it's faster to implement it like this
export const success = (x) => (task) => {
  task.success(x);
};

export const error = (e) => (task) => {
  task.error(e);
};

export const cancel = () => (task) => {
  task.cancel();
};

export const never = () => (task) => {};

export const _bind = (x, f) => (task) => {
  const error = (e) => {
    task.error(e);
  };

  const cancel = () => {
    task.cancel();
  };

  const t1 = run(x, (value) => {
    const t2 = run(f(value), (value) => {
      task.success(value);
    }, error, cancel);

    task.onAbort = () => {
      t2.abort();
    };
  }, error, cancel);

  task.onAbort = () => {
    t1.abort();
  };
};

export const _finally = (before, after) => (task) => {
  const error = (e) => {
    task.error(e);
  };

  const t1 = run(before, (value) => {
    // This task is run no matter what, even if it is aborted
    run(after, (_) => {
      task.success(value);

    }, error, () => {
      task.cancel();
    });

  }, (e) => {
    // Errors have precedence over cancellations
    const propagate = () => {
      task.error(e);
    };

    // This task is run no matter what, even if it is aborted
    run(after, propagate, error, propagate);
  });

  // TODO should this run the `after` task ?
  task.onAbort = () => {
    t1.abort();
  };
};

export const on_error = (x, f) => (task) => {
  const success = (value) => {
    task.success(value);
  };

  const cancel = () => {
    task.cancel();
  };

  const t1 = run(x, success, (e) => {
    const t2 = run(f(e), success, (e) => {
      task.error(e);
    }, cancel);

    // TODO should this abort ?
    task.onAbort = () => {
      t2.abort();
    };
  }, cancel);

  task.onAbort = () => {
    t1.abort();
  };
};

export const on_cancel = (x, y) => (task) => {
  const success = (value) => {
    task.success(value);
  };

  const error = (e) => {
    task.error(e);
  };

  const t1 = run(x, success, error, () => {
    const t2 = run(y, success, error, () => {
      task.cancel();
    });

    // TODO should this abort ?
    task.onAbort = () => {
      t2.abort();
    };
  });

  task.onAbort = () => {
    t1.abort();
  };
};

export const execute = (f) => (task) => {
  try {
    task.success(f());
  } catch (e) {
    task.error(e);
  }
};

// This can be implemented purely with bind + wrap,
// but it's more efficient to implement it with the FFI
export const ignore = (x) => (task) => {
  const t = run(x, (_) => {
    task.success(undefined);

  }, (e) => {
    task.error(e);

  }, () => {
    task.cancel();
  });

  task.onAbort = () => {
    t.abort();
  };
};

export const thread = (x) => (task) => {
  // TODO should this use nextTick or something ?
  task.success(new Thread(x));
};

export const thread_wait = (x) => (task) => {
  // TODO should this use nextTick or something ?
  x.wait(task);
};

export const thread_kill = (x) => (task) => {
  // TODO should this use nextTick or something ?
  x.kill();
  task.success(undefined);
};

const abortAll = (tasks) => {
  // TODO is it faster to use a var or a let ?
  for (let i = 0; i < tasks["length"]; ++i) {
    tasks[i].abort();
  }
};

// TODO verify that this works correctly in all situations
export const concurrent = (a) => (task) => {
  const out = new Array(a["length"]);

  const tasks = [];

  let pending = a["length"];

  let failed = false;

  const onSuccess = () => {
    --pending;
    if (pending === 0) {
      task.success(out);
    }
  };

  const onError = (e) => {
    failed = true;
    abortAll(tasks);
    task.error(e);
  };

  const onCancel = () => {
    failed = true;
    abortAll(tasks);
    task.cancel();
  };

  for (let i = 0; i < a["length"]; ++i) {
    if (failed) {
      break;

    } else {
      const t = run(a[i], (value) => {
        out[i] = value;
        onSuccess();
      }, onError, onCancel);

      tasks["push"](t);
    }
  }

  task.onAbort = () => {
    abortAll(tasks);
  };
};

// TODO verify that this works correctly in all situations
export const race = (a) => (task) => {
  const tasks = [];

  let done = false;

  const onSuccess = (value) => {
    done = true;
    abortAll(tasks);
    task.success(value);
  };

  const onError = (e) => {
    done = true;
    abortAll(tasks);
    task.error(e);
  };

  // TODO should it only cancel if all the tasks fail ?
  const onCancel = () => {
    done = true;
    abortAll(tasks);
    task.cancel();
  };

  // TODO is it faster to use var or let ?
  for (let i = 0; i < a["length"]; ++i) {
    if (done) {
      break;

    } else {
      tasks["push"](run(a[i], onSuccess, onError, onCancel));
    }
  }

  task.onAbort = () => {
    abortAll(tasks);
  };
};


// Often-used functionality
export const delay = (ms) => (task) => {
  const timer = setTimeout(() => {
    task.success(undefined);
  }, ms);

  task.onAbort = () => {
    clearTimeout(timer);
  };
};

export const log = (s) => (task) => {
  console["log"](s);
  task.success(undefined);
};
----

.Task.nu
[source]
----
(TYPE (Task Value))

(TYPE (Thread Value))

(TYPE Error)

(INTERFACE T
  (Error<- :: (-> T Error)))

(EXPORT { error
          cancel
          never
          finally = _finally
          on-error = on_error
          on-cancel = on_cancel
          execute
          ignore
          thread
          thread/wait = thread_wait
          thread/kill! = thread_kill
          concurrent
          race
          delay
          log }

  (FFI-IMPORT "Task"
    (make_error :: (-> String Error))

    (run_root :: (-> (Task Void) Void))

    (success :: (FORALL A
                  (-> A (Task A))))

    (error :: (FORALL A
                (-> Error (Task A))))

    (cancel :: (FORALL A
                 (-> (Task A))))

    (never :: (FORALL A
                (-> (Task A))))

    (_bind :: (FORALL A B
                (-> (Task A)
                    (-> A (Task B))
                    (Task B))))

    (_finally :: (FORALL A
                   (-> (Task A)
                       (Task Void)
                       (Task A))))

    (on_error :: (FORALL A
                   (-> (Task A)
                       (-> Error (Task A))
                       (Task A))))

    (on_cancel :: (FORALL A
                    (-> (Task A)
                        (Task A)
                        (Task A))))

    (execute :: (FORALL A
                  (-> (-> A) (Task A))))

    (ignore :: (FORALL A
                 (-> (Task A)
                     (Task Void))))

    (thread :: (FORALL A
                 (-> (Task A) (Thread A))))

    (thread_wait :: (FORALL A
                      (-> (Thread A) (Task A))))

    (thread_kill :: (FORALL A
                      (-> (Thread A) (Task Void))))

    (concurrent :: (FORALL A
                     (-> @(Task A) (List (Task A)))))

    (race :: (FORALL A
               (-> @(Task A) (Task A))))

    (delay :: (-> Integer (Task Void)))

    (log :: (-> String (Task Void))))

  # TODO is there a better way of handling this ?
  (MACRO
    (FFI-PROGRAM-START)
      `(run_root (,(symbol "main"))))

  (IMPLEMENT String
    (Error<- x)
      (make_error x))

  (IMPLEMENT Task
    (wrap x)
      (success x)

    (bind x f)
      (_bind x f)))

(FUNCTION
  (forever :: (FORALL A
                (-> (Task Void) (Task A))))
  (forever task)
    (DO task
        (forever task)))

(FUNCTION
  (timeout :: (FORALL A
                (-> Integer (Task Void) (Task Void))))
  (timeout ms task)
    (race task (delay ms)))
----
