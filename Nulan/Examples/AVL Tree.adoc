[source]
----
(FLAG+ "require-annotations")


(TYPE Comparison
  (*less)
  (*equal)
  (*more))


(INTERFACE A
  (compare :: (-> A A Comparison)))


(FUNCTION
  (more? :: (FORALL A
              (-> A A Boolean)))

  (more? x y)
    (MATCH (compare x y)
      (*more)
        (*true)
      _
        (*false)))


(FUNCTION
  (less? :: (FORALL A
              (-> A A Boolean)))

  (less? x y)
    (MATCH (compare x y)
      (*less)
        (*true)
      _
        (*false)))


(FUNCTION
  (equal? :: (FORALL A
               (-> A A Boolean)))

  (equal? x y)
    (MATCH (compare x y)
      (*equal)
        (*true)
      _
        (*false)))
----

[source]
----
(FLAG+ "require-annotations")


# Binary tree
(INTERFACE A
  (empty? :: (-> A Boolean))
  (left :: (-> A A))
  (right :: (-> A A))
  (set-children :: (-> A A A A)))


# AVL tree
(INTERFACE A
  (depth :: (-> A Integer)))


(FUNCTION
  (set-balanced :: (FORALL A
                     (-> A A A A)))

  (set-balanced node l r)
    (LET l-depth = (depth l)
         r-depth = (depth r)

      # Left side is deeper
      (IF (more? l-depth (add r-depth 1))
        (LET ll = (left l)
             lr = (right l)

          (IF (more? (depth lr)
                     (depth ll))

            (LET lrl = (left lr)
                 lrr = (right lr)

              # Left rotate -> Right rotate
              (set-children lr (set-children l ll lrl)
                               (set-children node lrr r)))

            # Right rotate
            (set-children l ll (set-children node lr r))))

        # Right side is deeper
        (IF (more? r-depth (add l-depth 1))
          (LET rl = (left r)
               rr = (right r)

            (IF (more? (depth rl)
                       (depth rr))

              (LET rll = (left rl)
                   rlr = (right rl)

                # Right rotate -> Left rotate
                (set-children lr (set-children node l rll)
                                 (set-children r rlr rr)))

              # Left rotate
              (set-children r (set-children node l rl) rr)))

          # No balancing needed
          (set-children node l r)))))


(FUNCTION
  (concat :: (FORALL A
               (-> A A A)))

  (concat x y)
    (IF (empty? x)
      y
      (IF (empty? y)
        x
        # TODO what if the depths are the same ?
        (IF (less? (depth x)
                   (depth y))
          (set-balanced y (concat x (left y)) (right y))
          (set-balanced x (left x) (concat (right x) y))))))


(FUNCTION
  (insert-min :: (FORALL A
                   (-> A A A)))

  (insert-min node new)
    (IF (empty? node)
      new
      (set-balanced node (insert-min (left node) new) (right node))))


(FUNCTION
  (insert-max :: (FORALL A
                   (-> A A A)))

  (insert-max node new)
    (IF (empty? node)
      new
      (set-balanced node (left node) (insert-max (right node) new))))


(EXPORT { Dict get set remove has? dict sorted-dict }

  (INTERFACE A
    (get :: (FORALL Key Value
              (-> (A Key Value) Key (Maybe Value))))

    (set :: (FORALL Key Value
              (-> (A Key Value) Key Value (A Key Value))))

    (remove :: (FORALL Key Value
                 (-> (A Key Value) Key (A Key Value)))))


  (FUNCTION
    (has? :: (FORALL A Key Value
               (-> (A Key Value) Key Boolean)))

    (has? dict key)
      (MATCH (get dict key)
        (*nothing)
          (*false)

        (*something _)
          (*true)))


  (TYPE (Sorted-Dict Key Value)
    (*nil { sort = (-> Key Key Comparison) })

    (*tree { left = (Sorted-Dict Key Value)
             right = (Sorted-Dict Key Value)
             sort = (-> Key Key Comparison)
             key = Key
             value = Value
             depth = Integer }))


  # TODO is this valid ?
  (FUNCTION
    (sorted-dict :: (FORALL Key Value
                      (-> (Sorted-Dict Key Value))))
    (sorted-dict sort)
      (*nil { sort = sort }))


  (TYPE (Dict Key Value)
    (*dict (Sorted-Dict Key Value)))


  # TODO is this valid ?
  (FUNCTION
    (dict :: (FORALL Key Value
               (-> (Dict Key Value))))
    (dict)
      (*dict (sorted-dict compare)))


  (IMPLEMENT (FORALL Key Value
               (Dict Key Value))

    (compare (*dict (*nil _)) (*dict (*nil _)))
      (*equal)

    (compare (*dict (*nil _)) (*dict _))
      (*less)

    (compare (*dict _) (*dict (*nil _)))
      (*more)

    (compare (*dict (*tree x)) (*dict (*tree y)))
      (MATCH (compare x.key y.key)
        (*equal)
          (MATCH (compare x.left y.left)
            (*equal)
              (MATCH (compare x.right y.right)
                (*equal)
                  (*equal)


            )

        (*less)
          (MATCH (compare )

        (*more)
        )


    (get (*dict x) key)
      (*dict (get x key))

    (set (*dict x) key value)
      (*dict (set x key value))

    (remove (*dict x) key)
      (*dict (remove x key))

    (empty? (*dict x))
      (empty? x)

    (left (*dict x))
      (left x)

    (right (*dict x))
      (right x)

    (set-children (*dict x) l r)
      (*dict (set-children x l r))

    (depth (*dict x))
      (depth x))


  (IMPLEMENT (FORALL Key Value
               (Sorted-Dict Key Value))

    (get (*nil _) _)
      (*nothing)

    (get (*tree node) key)
      (MATCH (node.sort key node.key)
        (*equal)
          (*something node.value)

        (*less)
          (get node.left key)

        (*more)
          (get node.right key))


    (set (*nil x) key value)
      (*tree { left = (*nil x)
               right = (*nil x)
               sort = x.sort
               key = key
               value = value
               depth = 1 })

    (set node key value)
      (LET (*tree x) = node
        (MATCH (node.sort key x.key)
          (*equal)
            (*tree { @x key = key
                        value = value })

          (*less)
            (set-balanced node
              (set x.left key value)
              x.right)

          (*more)
            (set-balanced node
              x.left
              (set x.right key value))))


    (remove (*nil x) _)
      (*nil x)

    (remove node key)
      (LET (*tree x) = node
        (MATCH (node.sort key x.key)
          (*equal)
            (concat x.left x.right)

          (*less)
            (set-balanced node
              (remove x.left key)
              x.right)

          (*more)
            (set-balanced node
              x.left
              (remove x.right key))))


    (empty? (*nil _))
      (*true)

    (empty? (*tree _))
      (*false)


    (left (*tree x))
      x.left

    (left (*nil _))
      (FAIL)


    (right (*tree x))
      x.right

    (right (*nil _))
      (FAIL)


    (set-children (*tree x) l r)
      (LET d = (max (depth l)
                    (depth r))
        (*tree { @x left  = l
                    right = r
                    depth = (add d 1) }))

    (set-children (*nil _) _ _)
      (FAIL)


    (depth (*tree x))
      x.depth

    (depth (*nil _))
      0))
----
