.Stream.nu
[source]
----
(USE {} = "nulan:String")
(USE {} = "nulan:Maybe")
(USE {} = "nulan:Task")

(TYPE (Stream a))

(TYPE (Input a))

(TYPE (Output a))

(EXPORT { make-stream = make_stream
        | with-stream
        | push! = push
        | peek
        | pull! = pull }

  (FFI-IMPORT "FFI/Stream"
    (make_stream :: (-> (-> (Input a) (Task Void))
                        (Stream a)))

    (with_stream :: (-> (Stream a)
                        (-> a b)
                        (-> b)
                        (-> (Output b) (Task c))
                        (Task c)))

    (push :: (-> (Input a) a (Task Void)))

    (peek :: (-> (Output a) (Task a)))

    (pull :: (-> (Output a) (Task a))))

  (FUNCTION
    (with-stream :: (-> (Stream a)
                        (-> (Output (Maybe a)) (Task b))
                        (Task b)))
    (with-stream s f)
      (with_stream s *some *none f)))


#/(FUNCTION
  (pipe-stream :: (-> (Stream a)
                      (-> (Output a) (Input b) (Task Void))
                      (Stream b)))
  (pipe-stream s f)
    (make-stream -> out
      (with-stream s -> in
        (f in out))))/#

(FUNCTION
  (each :: (-> (Stream a)
               (-> a (Task Void))
               (Task Void)))
  (each s f)
    (with-stream s -> in
      (LOOP next
        (DO-MATCH (pull! in)
          (*none)
            void
          (*some value)
            (DO (f value)
                (next))))))

(FUNCTION
  (merge :: (-> @(Stream a) (Stream a)))
  (merge @s)
    (make-stream -> out
      (ignore-concurrent
        @(map s -> s
           (each s -> value
             (push! out value))))))

(FUNCTION
  (map :: (-> (Stream a)
              (-> a b)
              (Stream b)))
  (map in f)
    (make-stream -> out
      (each in -> value
        (push! out (f value)))))

(FUNCTION
  (keep :: (-> (Stream a)
               (-> a Boolean)
               (Stream a)))
  (keep in f)
    (make-stream -> out
      (each in -> value
        (IF (f value)
          (push! out value)
          void))))

(FUNCTION
  (foldl :: (-> a
                (Stream b)
                # TODO maybe the function should return `a` rather than `(Task a)` ?
                (-> a b (Task a))
                (Task a)))
  (foldl init s f)
    (with-stream s -> in
      (LOOP next
          | old = init
        (DO-MATCH (pull! in)
          (*none)
            (wrap old)
          (*some value)
            (DO new = (f old value)
                (next new))))))

(FUNCTION
  # TODO is this correct ?
  (join :: (-> (Stream a) (Task a)))
  (join in)
    (foldl (empty) in -> old new
      (wrap (concat old new))))

(FUNCTION
  # TODO this type signature is probably wrong
  (flatten :: (-> (Stream a) (Stream b)))
  (flatten in)
    (make-stream -> out
      (each in -> value
        (ignore-sequential
          @(map value -> value
             (push! out value))))))

(FUNCTION
  (split-lines :: (-> (Stream String) (Stream String)))
  (split-lines in)
    (<< (map in -> s (split s "\n"))
        (flatten)))

(FUNCTION
  (generate :: (-> a (-> a a) (Stream a)))
  (generate init f)
    (make-stream -> out
      (LOOP next
          | x = init
        (DO (push! out x)
            (next (f x))))))
----

.Examples
[source]
----
(FUNCTION
  (generate-add :: (-> Integer (Stream Integer)))
  (generate-add init inc)
    (generate init -> x (add x inc)))

(FUNCTION
  (generate-multiply :: (-> Integer (Stream Integer)))
  (generate-multiply init inc)
    (generate init -> x (multiply x inc)))

(FUNCTION
  (accumulate :: (-> (Stream Integer) (Task Integer)))
  (accumulate in)
    (foldl 0 in -> old value
      (LET new = (add old value)
        (DO (log new)
            (wrap new)))))


# More verbose version with comments
(FUNCTION (main)
  (LET # Lazily generates the stream [0 1 2 3 4 ...]
       x = (generate-add 0 1)

       # Lazily generates the stream [1 2 4 8 16 ...]
       y = (generate-multiply 1 2)

       # Merges the two streams in a non-deterministic fashion
       z = (merge x y)

    # Accumulates and logs the sum of the merged stream
    (accumulate z)))


# More concise version
(FUNCTION (main)
  (accumulate (merge (generate-add 0 1)
                     (generate-multiply 1 2))))
----
