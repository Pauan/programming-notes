.Stream.nu
[source]
----
(USE {} = "nulan:Task")

(TYPE (Stream A))

(EXPORT { stream/fixed = stream_fixed
          stream/sliding = stream_sliding
          stream/dropping = stream_dropping
          peek
          pull! = pull
          push! = push
          stream/close! = close }

  (FFI-IMPORT "Stream"
    (stream_fixed :: (FORALL A
                       (-> Integer (Task (Stream A)))))

    (stream_sliding :: (FORALL A
                         (-> Integer (Task (Stream A)))))

    (stream_dropping :: (FORALL A
                          (-> Integer (Task (Stream A)))))

    (peek :: (FORALL A
               (-> (Stream A) (Task A))))

    (pull :: (FORALL A
               (-> (Stream A) (Task A))))

    (push :: (FORALL A
               (-> (Stream A) A (Task Void))))

    (close :: (FORALL A
                (-> (Stream A) (Task Void))))))

(FUNCTION
  (stream :: (FORALL A
               (-> (Task (Stream A)))))
  (stream)
    (stream/fixed 5))

(FUNCTION
  (w/stream :: (FORALL A
                 (-> (Task A)
                     (Task Void))))
  (w/stream task)
    (on-cancel
      (ignore task)
      (wrap (void))))

(FUNCTION
  (w/stream-close! :: (FORALL A B
                        (-> (Stream A)
                            (Task B)
                            (Task Void))))
  (w/stream-close! out task)
    # TODO if out gets closed, this may call stream/close! twice
    # TODO what if it errors ?
    (w/stream
      (finally task
               (stream/close! out))))

# TODO find a better name for this
# TODO maybe get rid of this ?
(FUNCTION
  (stream/generate :: (FORALL A B
                        (-> (Stream A)
                            (-> (Stream A) (Task B))
                            (Task (Stream A)))))
  (stream/generate out f)
    (DO (ignore-thread
          (w/stream-close! out
            (f out)))
        (wrap out)))

(FUNCTION
  (stream/each! :: (FORALL A
                     (-> (Stream A)
                         (-> A (Task Void))
                         (Task Void))))
  (stream/each! in f)
    (w/stream
      (forever
        (DO value = (pull! in)
            (f value)))))

(FUNCTION
  (pipe! :: (FORALL A
              (-> (Stream A)
                  (Stream A)
                  (Task Void))))
  (pipe! from to)
    (stream/each! from -> value
      (push! to value)))

(FUNCTION
  (stream/merge! :: (FORALL A
                      (-> @(Stream A)
                         (Stream A)
                         (Task Void))))
  (stream/merge! @in out)
    (ignore-concurrent
      @(map in -> in
         (pipe! in out))))

(FUNCTION
  (stream/map! :: (FORALL A B
                    (-> (Stream A)
                        (Stream B)
                        (-> A B)
                        (Task Void))))
  (stream/map! in out f)
    (stream/each! in -> value
      (push! out (f value))))

(FUNCTION
  (stream/foldl! :: (FORALL A B
                      (-> A
                          (Stream B)
                          (-> A B (Task A))
                          (Task A))))
  (stream/foldl! init in f)
    (LOOP next
        | old = init
      # TODO doesn't this generate a huge chain of `on-cancel`s ?
      (on-cancel
        # TODO even though this is tail-recursive, does it generate a huge chain of `_bind` ?
        (DO value = (pull! in)
            new = (f old value)
            (next new))
        (wrap old))))

(FUNCTION
  (stream/join! :: (FORALL A
                     (-> (Stream A) (Task A))))
  (stream/join! in)
    (stream/foldl! (empty) in -> old value
      (concat old value)))

(FUNCTION
  # TODO this type signature is probably wrong
  (stream/flatten! :: (FORALL A B
                        (-> (Stream (A B))
                            (Stream B)
                            (Task Void))))
  (stream/flatten! in out)
    (stream/each! in -> value
      (ignore-sequence
        @(map value -> value
           (push! value out)))))
----

.Examples
[source]
----
(FUNCTION
  (generate/add! :: (-> (Stream Integer) (Task Void)))
  (generate/add! out)
    (LOOP next
        | i = 0
      (DO (push! out i)
          (next (add i 1)))))

(FUNCTION
  (generate/multiply! :: (-> (Stream Integer) (Task Void)))
  (generate/multiply! out)
    (LOOP next
        | i = 1
      (DO (push! out i)
          (next (multiply i 2)))))

(FUNCTION
  (accumulate :: (-> (Stream Integer) (Task Integer)))
  (accumulate in)
    (stream/foldl! 0 in -> old value
      (LET new = (add old value)
        (DO (log new)
            (wrap new)))))


# Using threads
(DO # Lazily generates the stream [0 1 2 3 4 ...]
    x = (stream/generate (stream) generate-add!)

    # Lazily generates the stream [1 2 4 8 16 ...]
    y = (stream/generate (stream) generate/multiply!)

    # Merges the two streams in a non-deterministic fashion
    z = (stream/generate (stream) -> out
          (stream/merge! x y out))

    # Accumulates and logs the sum of the merged stream
    (ignore
      (accumulate z)))


# Using concurrent
(DO x = (stream)
    y = (stream)
    z = (stream)

    (ignore-concurrent
      # Lazily generates the stream [0 1 2 3 4 ...]
      (generate-add! x)

      # Lazily generates the stream [1 2 4 8 16 ...]
      (generate-multiply! y)

      # Merges the two streams in a non-deterministic fashion
      (stream/merge! x y z)

      # Accumulates and logs the sum of the merged stream
      (accumulate z)))


# Using a single Stream
(DO x = (stream)
  (ignore-concurrent
    # Lazily generates the stream [0 1 2 3 4 ...]
    (generate-add! x)

    # Lazily generates the stream [1 2 4 8 16 ...]
    (generate-multiply! x)

    # Accumulates and logs the sum of the merged stream
    (accumulate x)))
----
