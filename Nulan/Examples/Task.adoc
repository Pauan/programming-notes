.Task.nu
[source]
----
(TYPE Void)

(TYPE (Task Value))

(TYPE (Thread Value))

(EXPORT { FFI-PROGRAM-START
          void = _void
          error
          cancel
          never
          # TODO maybe get rid of finally ?
          finally = _finally
          on-cancel = on_cancel
          W/RESOURCE
          # TODO maybe rename `execute` to something else ?
          Task<- = execute
          # TODO get rid of all thread stuff ?
          thread
          thread-wait = thread_wait
          thread-kill! = thread_kill
          sequential
          concurrent
          fastest
          log }

  (FFI-IMPORT "FFI/Task"
    _void :: (Task Void)


    (run_root :: (-> (-> (Task Void)) Void))


    (success :: (FORALL A
                  (-> A (Task A))))


    "When executed, causes an error to occur."
    (error :: (FORALL A
                (-> String (Task A))))


    "When executed, causes a cancellation to occur."
    (cancel :: (FORALL A
                 (-> (Task A))))


    "When executed, never returns, errors, or cancels."
    (never :: (FORALL A
                (-> (Task A))))


    (_bind :: (FORALL A B
                (-> (Task A)
                    (-> A (Task B))
                    (Task B))))


    (with_resource :: (FORALL A B
                        (-> (Task A)
                            (-> A (Task B))
                            (-> A (Task Void))
                            (Task B))))


    "When executed, executes the first `Task`, and then executes the second
     `Task`. The second `Task` is *always* executed, even if the first `Task`
     returns, errors, cancels, or terminates."
    (_finally :: (FORALL A
                   (-> (Task A)
                       (Task Void)
                       (Task A))))


    "When executed, executes the first `Task`.

     If the `Task` succeeds, it will call the function with the value of the
     `Task`, and then executes the `Task` that the function returns.

     If the `Task` cancels, it will execute the second `Task`."
    (on_cancel :: (FORALL A B
                    (-> (Task A)
                        (-> A (Task B))
                        (Task B)
                        (Task B))))


    "When executed, calls the function.

     If the function throws an exception, then that is captured and converted
     into a `Task`.

     If the function does not throw an exception, then the return value is
     put into a `Task`.

     ''''

     Pure code is allowed to throw exceptions, but it's not possible to deal
     with exceptions in pure code. By using `Task<-`, you can take a pure
     computation (which potentially throws an exception), convert it into a
     `Task`, and then deal with it:

     [source,nulan]
     ----
     (DO (Task<- -> (foo))
         (bar))
     ----

     You should use `Task<-` when you have a pure *computation* that you want
     to convert into a `Task`.

     If you already have a `Task`, then you don't need to use `Task<-`.

     In addition, if you have a pure *value* that you want to convert into a
     `Task`, you can just use `wrap` instead:

     [source,nulan]
     ----
     (DO (wrap 5)
         (bar))
     ----

     The only difference between `wrap` and `Task<-` is that `wrap` doesn't
     capture thrown exceptions. So if your code doesn't throw exceptions,
     then using `wrap` is perfectly fine."
    (execute :: (FORALL A
                  (-> (-> A) (Task A))))


    "When executed, starts executing the `Task` in a new thread, then
     immediately returns the `Thread`.

     Any errors are logged to the console.

     ''''

     That means that the `Task` will execute in parallel with all other
     `Task`s in the program:

     [source,nulan]
     ----
     # This will simultaneously log both 1 and 2
     (DO (ignore-thread (forever (log "1")))
         (ignore-thread (forever (log "2"))))
     ----

     Sometimes that is exactly what you want, but you should use `thread`
     sparingly: `Task`s executing simultaneously at arbitrary times can make
     your program much more difficult to understand.

     Instead, consider using `concurrent` or `fastest`, which are much easier
     to understand. Using `concurrent` or `fastest` also handles errors better
     than `thread`.

     So, when should you use `thread`? Well, basically, whenever `concurrent`
     and `fastest` don't work for what you're trying to do.

     But perhaps you can find an alternate way of writing your program that
     _does_ work with `concurrent` or `fastest`."
    (thread :: (FORALL A
                 (-> (Task A) (Thread A))))


    "When executed, waits for the `Thread` to finish, then returns the value
     of the `Thread`.

     ''''

     When a `Task` is executed in a new thread using `thread`, it will execute
     in parallel with all other `Task`s. That means you can no longer get the
     return value of that `Task`.

     But by using `thread-wait`, you can wait for a `Thread` to finish, so
     that you can get the return value of the `Task`:

     [source,nulan]
     ----
     (DO t = (thread (foo))
         # Waits for the thread to finish,
         # then returns the value of (foo)
         (thread-wait t))
     ----

     Of course, in the above example it would have been better to just use
     `(foo)` directly, and not use `thread` at all. It becomes more
     useful when using multiple threads:

     [source,nulan]
     ----
     (DO t1 = (thread (foo))
         t2 = (thread (bar))
         v1 = (thread-wait t1)
         v2 = (thread-wait t2)
         (qux v1 v2))
     ----

     The above code will execute `(foo)` and `(bar)` in parallel, then wait
     for both to complete, and then call `qux` with the return value of
     `(foo)` and `(bar)`.

     However, the above example can instead be written using `concurrent`,
     which is more concise, more efficient, and handles errors better than
     `thread`:

     [source,nulan]
     ----
     (DO (list v1 v2) = (concurrent (foo) (bar))
         (qux v1 v2))
     ----

     So you should prefer using `concurrent` rather than `thread-wait`,
     whenever you can."
    (thread_wait :: (FORALL A
                      (-> (Thread A) (Task A))))


    "When executed, kills the `Thread`, terminating any partially-complete
     computations.

     It will try to stop the computations as soon as possible, but they might
     not be stopped immediately. And in some unusual circumstances, some
     computations may still occur even after the `Thread` is killed.

     If the `Thread` is already finished, this has no effect.

     ''''

     This can be used to stop a long-running computation:

     [source,nulan]
     ----
     (DO t = (thread (forever (log "1")))
         (delay 2000)
         (thread-kill! t))
     ----

     The above code will log `"1"` to the console forever, but after `2000`
     milliseconds, it will kill the `Thread`, causing it to stop logging.

     However, the above example can instead be written using `fastest`, which
     is more concise, more efficient, and handles errors better than `thread`:

     [source,nulan]
     ----
     (fastest
       (forever (log "1"))
       (delay 2000))
     ----

     So you should prefer using `fastest` rather than `thread-kill!`, whenever
     you can."
    (thread_kill :: (FORALL A
                      (-> (Thread A) (Task Void))))


    "When executed, executes all the `Task`s in the `List`, one at a time,
     from left to right, then returns a `List` of the return values of the
     `Task`s.

     ''''

     This is the same as using `DO`:

     [source,nulan]
     ----
     (DO a = (foo)
         b = (bar)
         c = (qux)
         (wrap (list a b c)))
     ----

     [source,nulan]
     ----
     (sequential (foo) (bar) (qux))
     ----

     The above two code examples are equivalent: both execute three `Task`s
     sequentially, returning a `List` of the results.

     The difference is that `sequential` can take in a `List` of `Task`s:

     [source,nulan]
     ----
     (sequential @list-of-tasks)
     ----

     In this case, we have no clue how big `list-of-tasks` is. It could
     contain dozens, hundreds, or even thousands of `Task`s.

     With `DO`, you can only execute a fixed number of `Task`s, but with
     `sequential` you can execute a variable number of `Task`s."
    (sequential :: (FORALL A
                     (-> @(Task A) (Task (List A)))))


    "When executed, executes all the `Task`s in the `List` in parallel, and
     when they're all finished, returns a `List` of the return values of the
     `Task`s.

     If any of the `Task`s errors or cancels, the remaining `Task`s are
     terminated.

     ''''

     If you need to execute `Task`s in parallel, this is a much nicer
     alternative to using `thread`:

     [source,nulan]
     ----
     (DO t1 = (thread (foo))
         t2 = (thread (bar))
         t3 = (thread (qux))
         v1 = (thread-wait t1)
         v2 = (thread-wait t2)
         v3 = (thread-wait t3)
         (wrap (list v1 v2 v3)))
     ----

     [source,nulan]
     ----
     (concurrent (foo) (bar) (qux))
     ----

     The above two code examples are equivalent: they both execute three
     `Task`s in parallel, then waits for them all to complete, and then
     returns a `List` with the return values.

     But `concurrent` is much more concise, and more efficient too! In
     addition, it handles errors much better than `thread`.

     Also, `concurrent` accepts a `List` of `Task`s, which is much trickier
     to do with `thread`:

     [source,nulan]
     ----
     (concurrent @list-of-tasks)
     ----

     So you should prefer using `concurrent` rather than `thread`."
    (concurrent :: (FORALL A
                     (-> @(Task A) (Task (List A)))))


    "When executed, executes all the `Task`s in the `List` in parallel.

     The `Task` that returns first is the final result.

     If any of the `Task`s returns, errors, or cancels, the remaining `Task`s
     are terminated.

     ''''

     This is a nicer alternative to `thread-kill!`:

     [source,nulan]
     ----
     (DO t = (thread (foo))
         (delay 2000)
         (thread-kill! t))
     ----

     [source,nulan]
     ----
     (fastest (foo) (delay 2000))
     ----

     The above two code examples are equivalent: they both execute `(foo)`,
     and then terminates it if it takes longer than `2000` milliseconds.

     But `fastest` is more concise, and more efficient too! In addition, it
     handles errors much better than `thread`.

     Also, `fastest` accepts a `List` of `Task`s, which is much trickier
     to do with `thread`:

     [source,nulan]
     ----
     (fastest @list-of-tasks)
     ----

     Also, `fastest` returns the value of whichever `Task` finished first,
     which is *incredibly* hard to do with `thread`:

     [source,nulan]
     ----
     (DO x = (fastest (foo) (bar) (qux))
         (corge x))
     ----

     So you should prefer using `fastest` rather than `thread`."
    (fastest :: (FORALL A
                  (-> @(Task A) (Task A))))


    "When executed, it will log the `String` to the console, and then returns
     `Void`.

     ''''

     [source,nulan]
     ----
     # Logs 1, then 2, then 3 to the console
     (DO (log "1")
         (log "2")
         (log "3"))
     ----"
    (log :: (-> String (Task Void))))

  # TODO is there a better way of handling this ?
  (MACRO
    "Calls the function `main` (which is supposed to return a `Task`) and then
     executes the `Task`. Any errors are logged to the console."
    (FFI-PROGRAM-START)
      `(run_root ,(symbol "main")))

  (MACRO
    "When executed, executes the first `Task`, binding the return value to a
     variable. Then the second `Task` is executed, and afterwards the third
     `Task` is executed. The third `Task` is *always* executed, even if the
     second `Task` returns, errors, cancels, or terminates. If the second
     `Task` returns, then that is the final return value.

     This is very useful for initializing a resource, using the resource, and
     then cleaning up the resource:

     [source,nulan]
     ----
     (W/RESOURCE x = (open-file \"foo\")
       (use-file x)
       (close-file x))
     ----

     If you had used `DO` and `finally`, then the file may end up leaking,
     but by using `W/RESOURCE` you guarantee that the file will *always* be
     closed."
    (W/RESOURCE `(,name = ,before) during after)
      `(with_resource ,before
         (-> ,name ,during)
         (-> ,name ,after)))

  (IMPLEMENT Task
    "When executed, returns its argument."
    (wrap x)
      (success x)

    "When executed, executes the `Task`, then passes the return value to
     the function, then returns the `Task` that the function returns."
    (bind x f)
      (_bind x f)))


(FUNCTION
  "When executed, executes the `Task` in a new thread, then immediately calls
   the function with the `Thread`, then executes the `Task` that the function
   returns. When that `Task` finishes (for any reason), it will then kill the
   `Thread`.

   ''''

   This is useful when you want to execute a `Task` in a new thread, and
   guarantee that the `Thread` will get cleaned up no matter what happens."
  (w/thread :: (FORALL A B
                 (-> (Task A)
                     (-> (Thread A) (Task B))
                     (Task B))))
  (w/thread task f)
    # TODO does this leak? should it use W/RESOURCE instead ?
    (DO t = (thread task)
      (finally (f t)
               (thread-kill! t))))

(FUNCTION
  "When executed, executes the `Task`.

   If the `Task` returns, then the final result is `Void`.

   If the `Task` errors, then this `Task` errors.

   If the `Task` cancels, then this `Task` cancels.

   ''''

   This is useful if you aren't interested in the return value of a `Task`:

   [source,nulan]
   ----
   (DO (ignore (foo))
       (bar))
   ----"
  (ignore :: (FORALL A
               (-> (Task A) (Task Void))))
  (ignore task)
    (DO _ = task
        void))

(FUNCTION
  "When executed, executes the `Task` forever, as quickly as possible."
  (forever :: (FORALL A
                (-> (Task Void) (Task A))))
  (forever task)
    (DO task
        (forever task)))

(FUNCTION
  "The same as `sequential`, except it returns `Void` rather than a `List`."
  (ignore-sequential :: (FORALL A
                          (-> @(Task A) (Task Void))))
  (ignore-sequential @in)
    (ignore (sequential @in)))

(FUNCTION
  "The same as `concurrent`, except it returns `Void` rather than a `List`."
  (ignore-concurrent :: (FORALL A
                          (-> @(Task A) (Task Void))))
  (ignore-concurrent @in)
    (ignore (concurrent @in)))

(FUNCTION
  "The same as `thread`, except it returns `Void` rather than a `Thread`."
  (ignore-thread :: (FORALL A
                      (-> (Task A) (Task Void))))
  (ignore-thread task)
    (ignore (thread task)))
----
