.Stream.js
[source,javascript]
----
const check_length = (task, i) => {
  // TODO should we allow for a buffer of size 0 ?
  if (i >= 1) {
    return true;
  } else {
    task.error(new Error("Expected 1 or greater but got " + i));
    return false;
  }
};

const error = (task) => {
  task.error(this._error);
};

const error_pull = (task) => {
  task.error(new Error("Cannot pull: stream is closed"));
};

const error_push = (task) => {
  task.error(new Error("Cannot push: stream is closed"));
};

const error_error = (task) => {
  task.error(new Error("Cannot error: stream is closed"));
};

const error_close = (task) => {
  task.error(new Error("Cannot close: stream is already closed"));
};


class StreamBase {
  constructor() {
    this._error = null;
    this._pullers = [];
  }

  cleanup() {
    this._pullers = null;
  }

  each(f) {
    // TODO is it faster to use var or let ?
    for (let i = 0; i < this._pullers["length"]; ++i) {
      f(this._pullers[i]);
    }
  }

  error(task, err) {
    this.each((x) => {
      x.error(err);
    });

    this.cleanup();
    this._error = err;

    this.pull = error;
    this.push = error;
    this.error = error;
    this.close = error;

    // TODO is this a good idea ?
    task.error(err);
  }

  close(task) {
    // TODO is this correct ?
    this.each((x) => {
      x.cancel();
    });

    this.cleanup();

    this.pull = error_pull;
    this.push = error_push;
    this.error = error_error;
    this.close = error_close;

    // TODO should this cancel ?
    task.success(undefined);
  }
}


class Stream extends StreamBase {
  constructor() {
    super();
    this._pushers = [];
  }

  cleanup() {
    super.cleanup();
    this._pushers = null;
  }

  each(f) {
    super.each(f);

    // TODO is it faster to use var or let ?
    for (let i = 0; i < this._pushers["length"]; ++i) {
      f(this._pushers[i].task);
    }
  }

  pull(task) {
    if (this._pushers["length"]) {
      const f = this._pushers["shift"]();
      f.task.success(undefined);
      task.success(f.value);

    } else {
      this._pullers["push"](task);
    }
  }

  push(task, value) {
    if (this._pullers["length"]) {
      const f = this._pullers["shift"]();
      f.success(value);
      task.success(undefined);

    } else {
      this._pushers["push"]({
        task: task,
        value: value
      });
    }
  }
}


class StreamBuffered extends StreamBase {
  constructor(limit) {
    super();
    this._limit = limit;
    this._buffer = [];
  }

  cleanup() {
    super.cleanup();
    this._limit = null;
    this._buffer = null;
  }

  pull(task) {
    if (this._buffer["length"]) {
      task.success(this._buffer["shift"]());

    } else {
      this._pullers["push"](task);
    }
  }

  push(task, value) {
    // If there is a pending pull
    if (this._pullers["length"]) {
      this._pullers["shift"]().success(value);
      task.success(undefined);

    // If there is room in the buffer
    } else if (this._buffer["length"] < this._limit) {
      this._buffer["push"](value);
      task.success(undefined);

    // Buffer is full
    } else {
      this.full(task, value);
    }
  }
}


class StreamFixed extends StreamBuffered {
  constructor(limit) {
    super(limit);
    this._pushers = [];
  }

  // TODO code duplication with Stream
  cleanup() {
    super.cleanup();
    this._pushers = null;
  }

  // TODO code duplication with Stream
  each(f) {
    super.each(f);

    // TODO is it faster to use var or let ?
    for (let i = 0; i < this._pushers["length"]; ++i) {
      f(this._pushers[i].task);
    }
  }

  pull(task) {
    // If there is stuff in the buffer
    if (this._buffer["length"]) {
      const value = this._buffer["shift"]();

      // If there is a pending push
      if (this._pushers["length"]) {
        const f = this._pushers["shift"]();
        this._buffer["push"](f.value);
        f.task.success(undefined);
      }

      task.success(value);

    // Buffer is empty, wait for push
    } else {
      this._pullers["push"](task);
    }
  }

  full(task, value) {
    this._pushers["push"]({
      task: task,
      value: value
    });
  }
}


class StreamSliding extends StreamBuffered {
  full(task, value) {
    // TODO more efficient function for this
    this._buffer["shift"]();
    this._buffer["push"](value);
    task.success(undefined);
  }
}


class StreamDropping extends StreamBuffered {
  full(task, value) {
    task.success(undefined);
  }
}


export const stream = () => (task) => {
  task.success(new Stream());
};

export const stream_fixed = (i) => (task) => {
  if (check_length(task, i)) {
    task.success(new StreamFixed(i));
  }
};

export const stream_sliding = (i) => (task) => {
  if (check_length(task, i)) {
    task.success(new StreamSliding(i));
  }
};

export const stream_dropping = (i) => (task) => {
  if (check_length(task, i)) {
    task.success(new StreamDropping(i));
  }
};

export const pull = (stream) => (task) => {
  stream.pull(task);
};

export const push = (stream, value) => (task) => {
  stream.push(task, value);
};

export const error = (stream, err) => (task) => {
  stream.error(task, err);
};

export const close = (stream) => (task) => {
  stream.close(task);
};
----

.Stream.nu
[source]
----
(TYPE (Stream A))

(EXPORT { stream
          stream/fixed = stream_fixed
          stream/sliding = stream_sliding
          stream/dropping = stream_dropping
          pull! = pull
          push! = push
          stream/error! = error
          stream/close! = close }

  (FFI-IMPORT "Stream"
    (stream :: (FORALL A
                 (-> (Task (Stream A)))))

    (stream_fixed :: (FORALL A
                       (-> Integer (Task (Stream A)))))

    (stream_sliding :: (FORALL A
                         (-> Integer (Task (Stream A)))))

    (stream_dropping :: (FORALL A
                          (-> Integer (Task (Stream A)))))

    (pull :: (FORALL A
               (-> (Stream A) (Task A))))

    (push :: (FORALL A
               (-> (Stream A) A (Task Void))))

    (error :: (FORALL A
                (-> (Stream A) Error (Task Void))))

    (close :: (FORALL A
                (-> (Stream A) (Task Void))))))

(FUNCTION
  (stream/each :: (FORALL A
                    (-> (Stream A)
                        (-> A (Task Void))
                        (Task Void))))
  (stream/each in f)
    (on-cancel
      (forever
        (DO value = (pull! in)
            (f value)))
      (wrap (void))))

(FUNCTION
  (pipe :: (FORALL A
             (-> (Stream A)
                 (Stream A)
                 (Task Void))))
  (pipe from to)
    (stream/each from -> value
      (push! to value)))

(FUNCTION
  (stream/make :: (FORALL A B
                    (-> (-> (Stream A) (Task B))
                        (Task (Stream A)))))
  (stream/make f)
    (DO out = (stream)
        # TODO if out gets closed, this may call stream/close! twice
        (ignore
          (thread
            # TODO what if it errors ?
            (finally (f out)
                     (stream/close! out))))
        (wrap out)))

(FUNCTION
  (stream/merge :: (FORALL A
                     (-> @(Stream A) (Task (Stream A)))))
  (stream/merge @in)
    (stream/make -> out
      (concurrent
        @(map in -> in
           (pipe in out)))))

(FUNCTION
  (stream/map :: (FORALL A B
                   (-> (Stream A)
                       (-> A B)
                       (Task (Stream B)))))
  (stream/map in f)
    (stream/make -> out
      (stream/each in -> value
        (push! out (f value)))))

(FUNCTION
  (stream/foldl :: (FORALL A B
                     (-> A
                         (Stream B)
                         (-> A B (Task A))
                         (Task A))))
  (stream/foldl init s f)
    (LOOP next
        | old = init
      # TODO doesn't this generate a huge chain of `on-cancel`s ?
      (on-cancel
        # TODO even though this is tail-recursive, does it generate a huge chain of `_bind` ?
        (DO value = (pull! s)
            new = (f old value)
            (next new))
        (wrap old))))

(FUNCTION
  (stream/join :: (FORALL A
                    (-> (Stream A) (Task A))))
  (stream/join s)
    (stream/foldl (empty) s -> old value
      (concat old value)))
----

.Examples
[source]
----
(DO # Lazily generates the stream [0 1 2 3 4 ...]
    x = (stream/make -> out
          (LOOP next
              | i = 0
            (DO (push! out i)
                (next (add i 1)))))

    # Lazily generates the stream [1 2 4 8 16 ....]
    y = (stream/make -> out
          (LOOP next
              | i = 1
            (DO (push! out i)
                (next (multiply i 2)))))

    # Merges the two streams in a non-deterministic fashion
    z = (stream/merge x y)

    # Accumulates and logs the sum of the merged stream
    (stream/foldl 0 z -> old value
      (LET new = (add old value)
        (DO (log new)
            (wrap new)))))
----
