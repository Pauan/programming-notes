.Task.nu
[source]
----
(TYPE Void)

(TYPE (Task Value))

(EXPORT { FFI-PROGRAM-START
          void = _void
          error
          cancel
          never
          on-cancel = on_cancel
          # TODO maybe rename `execute` to something else ?
          Task<- = execute
          sequential
          concurrent
          fastest
          log
          warn }

  (FFI-IMPORT "FFI/Task"
    _void :: (Task Void)


    (run_root :: (-> (-> (Task Void)) Void))


    (success :: (FORALL A
                  (-> A (Task A))))


    "When executed, causes an error to occur."
    (error :: (FORALL A
                (-> String (Task A))))


    "When executed, causes a cancellation to occur."
    (cancel :: (FORALL A
                 (-> (Task A))))


    "When executed, never returns, errors, or cancels."
    (never :: (FORALL A
                (-> (Task A))))


    (_bind :: (FORALL A B
                (-> (Task A)
                    (-> A (Task B))
                    (Task B))))


    "When executed, executes the first `Task`.

     If the `Task` succeeds, it will call the function with the value of the
     `Task`, and then executes the `Task` that the function returns.

     If the `Task` cancels, it will execute the second `Task`."
    (on_cancel :: (FORALL A B
                    (-> (Task A)
                        (-> A (Task B))
                        (Task B)
                        (Task B))))


    "When executed, calls the function.

     If the function throws an exception, then that is captured and converted
     into a `Task`.

     If the function does not throw an exception, then the return value is
     put into a `Task`.

     ''''

     Pure code is allowed to throw exceptions, but it's not possible to deal
     with exceptions in pure code. By using `Task<-`, you can take a pure
     computation (which potentially throws an exception), convert it into a
     `Task`, and then deal with it:

     [source,nulan]
     ----
     (DO (Task<- -> (foo))
         (bar))
     ----

     You should use `Task<-` when you have a pure *computation* that you want
     to convert into a `Task`.

     If you already have a `Task`, then you don't need to use `Task<-`.

     In addition, if you have a pure *value* that you want to convert into a
     `Task`, you can just use `wrap` instead:

     [source,nulan]
     ----
     (DO (wrap 5)
         (bar))
     ----

     The only difference between `wrap` and `Task<-` is that `wrap` doesn't
     capture thrown exceptions. So if your code doesn't throw exceptions,
     then using `wrap` is perfectly fine."
    (execute :: (FORALL A
                  (-> (-> A) (Task A))))


    "When executed, executes all the `Task`s in the `List`, one at a time,
     from left to right, then returns a `List` of the return values of the
     `Task`s.

     ''''

     This is the same as using `DO`:

     [source,nulan]
     ----
     (DO a = (foo)
         b = (bar)
         c = (qux)
         (wrap (list a b c)))
     ----

     [source,nulan]
     ----
     (sequential (foo) (bar) (qux))
     ----

     The above two code examples are equivalent: both execute three `Task`s
     sequentially, returning a `List` of the results.

     The difference is that `sequential` can take in a `List` of `Task`s:

     [source,nulan]
     ----
     (sequential @list-of-tasks)
     ----

     In this case, we have no clue how big `list-of-tasks` is. It could
     contain dozens, hundreds, or even thousands of `Task`s.

     With `DO`, you can only execute a fixed number of `Task`s, but with
     `sequential` you can execute a variable number of `Task`s."
    (sequential :: (FORALL A
                     (-> @(Task A) (Task (List A)))))


    "When executed, executes all the `Task`s in parallel, and when they're all
     finished, returns a `List` of the return values of the `Task`s.

     If any of the `Task`s errors or cancels, the remaining `Task`s are
     terminated.

     ''''

     [source,nulan]
     ----
     (DO (list a b c) = (concurrent (foo) (bar) (qux))
         (corge a b c))
     ----

     The above code will execute `(foo)`, `(bar)`, and `(qux)` in parallel,
     and when they're all finished, `a` will be the result of `(foo)`, `b`
     will be the result of `(bar)`, and `c` will be the result of `(qux)`.

     You can also pass in a `List` of `Task`s:

     [source,nulan]
     ----
     (DO (list @a) = (concurrent @list-of-tasks)
         (corge a))
     ----"
    (concurrent :: (-> @(Task a) (Task (List a))))


    "When executed, executes all the `Task`s in the `List` in parallel.

     The `Task` that returns first is the final result.

     If any of the `Task`s returns, errors, or cancels, the remaining `Task`s
     are terminated.

     ''''

     [source,nulan]
     ----
     (DO x = (fastest (foo) (bar) (qux))
         (corge x))
     ----

     The above code executes `(foo)`, `(bar)`, and `(qux)` in parallel, and
     when one of them finishes, `x` will be the result of whichever finished
     first.

     You can also pass in a `List` of `Task`s:

     [source,nulan]
     ----
     (DO x = (fastest @list-of-tasks)
         (corge x))
     ----"
    (fastest :: (-> @(Task a) (Task a)))


    "When executed, it will log the `String` to the console, and then returns
     `Void`.

     ''''

     [source,nulan]
     ----
     # Logs 1, then 2, then 3 to the console
     (DO (log "1")
         (log "2")
         (log "3"))
     ----"
    (log :: (-> String (Task Void)))


    "When executed, it will log the `String` to the console, and then returns
     `Void`.

     ''''

     The difference between `log` and `warn` is: `warn` will indicate in
     some way that it is a warning, whereas `log` is for normal output.

     [source,nulan]
     ----
     # Logs 1, then 2, then 3 to the console
     (DO (warn "1")
         (warn "2")
         (warn "3"))
     ----"
    (warn :: (-> String (Task Void))))

  # TODO is there a better way of handling this ?
  (MACRO
    "Calls the function `main` (which is supposed to return a `Task`) and then
     executes the `Task`. Any errors are logged to the console."
    (FFI-PROGRAM-START)
      `(run_root ,(symbol "main")))

  (IMPLEMENT Task
    "When executed, returns its argument."
    (wrap x)
      (success x)

    "When executed, executes the `Task`, then passes the return value to
     the function, then returns the `Task` that the function returns."
    (bind x f)
      (_bind x f)))

(FUNCTION
  "When executed, executes the `Task`.

   If the `Task` returns, then the final result is `Void`.

   If the `Task` errors, then this `Task` errors.

   If the `Task` cancels, then this `Task` cancels.

   ''''

   This is useful if you aren't interested in the return value of a `Task`:

   [source,nulan]
   ----
   (DO (ignore (foo))
       (bar))
   ----"
  (ignore :: (FORALL A
               (-> (Task A) (Task Void))))
  (ignore task)
    (DO _ = task
        void))

(FUNCTION
  "When executed, executes the `Task` forever, as quickly as possible."
  (forever :: (FORALL A
                (-> (Task Void) (Task A))))
  (forever task)
    (DO task
        (forever task)))

(FUNCTION
  "The same as `sequential`, except it returns `Void` rather than a `List`."
  (ignore-sequential :: (FORALL A
                          (-> @(Task A) (Task Void))))
  (ignore-sequential @in)
    (ignore (sequential @in)))

(FUNCTION
  "The same as `concurrent`, except it returns `Void` rather than a `List`."
  (ignore-concurrent :: (FORALL A
                          (-> @(Task A) (Task Void))))
  (ignore-concurrent @in)
    (ignore (concurrent @in)))

(FUNCTION
  "When executed, executes the `Task`.

   If the `Task` succeeds, return `Void`.

   If the `Task` cancels, return `Void`.

   ''''

   This is useful if you want to execute a `Task`, but want to ignore
   cancellations."
  (ignore-cancel :: (-> (Task Void) (Task Void)))
  (ignore-cancel x)
    (on-cancel x
      (-> _ void)
      void))
----
