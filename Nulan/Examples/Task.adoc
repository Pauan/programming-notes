.Task.js
[source,javascript]
----
class Task {
  constructor(f, onSuccess, onError) {
    this._pending = true;
    this._onSuccess = onSuccess;
    this._onError = onError;
    this.onCancel = null;

    f(this);
  }

  success(value) {
    if (this._pending) {
      var f = this._onSuccess;

      this._pending = false;
      this._onSuccess = null;
      this._onError = null;
      this.onCancel = null;

      f(value);
    }
  }

  error(e) {
    if (this._pending) {
      var f = this._onError;

      this._pending = false;
      this._onSuccess = null;
      this._onError = null;
      this.onCancel = null;

      f(e);
    }
  }

  cancel() {
    if (this._pending) {
      var f = this.onCancel;

      this._pending = false;
      this._onSuccess = null;
      this._onError = null;
      this.onCancel = null; // TODO what if somebody sets onCancel after the Task is cancelled ?

      if (f !== null) {
        f();
      }
    }
  }
}


class Thread {
  constructor(task) {
    // 0 is pending
    // 1 is succeeded
    // 2 is errored
    // 3 is cancelled
    this._state = 0;
    this._value = null;
    this._listeners = [];

    this._task = new Task(task, (value) => {
      if (this._state === 0) {
        this._state = 1;
        this._value = value;

        // TODO this can be made a bit faster
        this._listeners["forEach"](function (x) {
          x.success(value);
        });

        this._listeners = null;
      }

    }, (e) => {
      if (this._state === 0) {
        this._state = 2;
        this._value = e;

        // TODO this can be made a bit faster
        this._listeners["forEach"](function (x) {
          x.error(e);
        });

        this._listeners = null;

        print_error(e);
      }
    });
  }

  wait(task) {
    switch (this._state) {
    case 0:
      this._listeners["push"](task);

      task.onCancel = () => {
        // TODO replace with faster `remove` function
        var i = this._listeners["indexOf"](task);
        // TODO assert that `i` is never `-1` ?
        if (i !== -1) {
          this._listeners["splice"](i, 1);
        }
      };
      break;

    case 1:
      task.success(this._value);
      break;

    case 2:
      task.error(this._value);
      break;

    // TODO is this correct ?
    case 3:
      task.cancel();
      break;
    }
  }

  kill() {
    if (this._state === 0) {
      var t = this._task;

      this._state = 3;
      // TODO should this cancel all the listeners ?
      this._listeners = null;
      this._task = null;

      t.cancel();
    }
  }
}


function noop() {}

// There's no standard way to cancel a Promise
function Task_from_Promise(f) {
  return function (task) {
    f()["then"](function (x) {
      task.success(x);
    }, function (e) {
      task.error(e);
    });
  };
}

function Promise_from_Task(task) {
  return new Promise(function (resolve, reject) {
    new Task(task, resolve, reject);
  });
}

function print_error(e) {
  console["error"](e["stack"]);
}

function make_error(s) {
  return new Error(s);
}

function run_root(task) {
  new Task(task, noop, print_error);
}

// This can be implemented purely with `execute`,
// but it's faster to implement it like this
function success(x) {
  return function (task) {
    task.success(x);
  };
}

function error(e) {
  return function (task) {
    task.error(e);
  };
}

function never() {
  return function (task) {};
}

function _bind(x, f) {
  return function (task) {
    function error(e) {
      task.error(e);
    }

    var t1 = new Task(x, function (value) {
      var t2 = new Task(f(value), function (value) {
        task.success(value);
      }, error);

      task.onCancel = function () {
        t2.cancel();
      };
    }, error);

    task.onCancel = function () {
      t1.cancel();
    };
  };
}

function _finally(before, after) {
  return function (task) {
    function error(e) {
      task.error(e);
    }

    var t1 = new Task(before, function (value) {
      // This task is run no matter what, even if it is cancelled
      new Task(after, function (_) {
        task.success(value);
      }, error);

    }, function (e) {
      // This task is run no matter what, even if it is cancelled
      new Task(after, function (_) {
        task.error(e);
      }, error);
    });

    // TODO should this run the `after` task ?
    task.onCancel = function () {
      t1.cancel();
    };
  };
}

function on_error(x, f) {
  return function (task) {
    function success(value) {
      task.success(value);
    }

    var t1 = new Task(x, success, function (e) {
      var t2 = new Task(f(e), success, function (e) {
        task.error(e);
      });

      task.onCancel = function () {
        t2.cancel();
      };
    });

    task.onCancel = function () {
      t1.cancel();
    };
  };
}

function execute(f) {
  return function (task) {
    try {
      task.success(f());
    } catch (e) {
      task.error(e);
    }
  };
}

// This can be implemented purely with bind + wrap,
// but it's more efficient to implement it with the FFI
function ignore(x) {
  return function (task) {
    var t = new Task(x, function (_) {
      task.success(undefined);
    }, function (e) {
      task.error(e);
    });

    task.onCancel = function () {
      t.cancel();
    };
  };
}

function thread(x) {
  return function (task) {
    // TODO should this use nextTick or something ?
    task.success(new Thread(x));
  };
}

function thread_wait(x) {
  return function (task) {
    // TODO should this use nextTick or something ?
    x.wait(task);
  };
}

function thread_kill(x) {
  return function (task) {
    // TODO should this use nextTick or something ?
    x.kill();
    task.success(undefined);
  };
}

function cancelAll(tasks) {
  for (var i = 0; i < tasks["length"]; ++i) {
    tasks[i].cancel();
  }
}

// TODO verify that this works correctly in all situations
function concurrent(a) {
  return function (task) {
    var out = new Array(a["length"]);

    var pending = a["length"];

    var tasks = [];

    var failed = false;

    function onSuccess() {
      --pending;
      if (pending === 0) {
        task.success(out);
      }
    }

    function onError(e) {
      failed = true;
      cancelAll(tasks);
      task.error(e);
    }

    for (var i = 0; i < a["length"]; ++i) {
      if (failed) {
        break;

      } else {
        (function (i) {
          var t = new Task(a[i], function (value) {
            out[i] = value;
            onSuccess();
          }, onError);

          tasks.push(t);
        })(i);
      }
    }

    task.onCancel = function () {
      cancelAll(tasks);
    };
  };
}

// TODO verify that this works correctly in all situations
function race(a) {
  return function (task) {
    var tasks = [];

    var done = false;

    function onSuccess(value) {
      done = true;
      cancelAll(tasks);
      task.success(value);
    }

    function onError(e) {
      done = true;
      cancelAll(tasks);
      task.error(e);
    }

    for (var i = 0; i < a["length"]; ++i) {
      if (done) {
        break;

      } else {
        tasks.push(new Task(a[i], onSuccess, onError));
      }
    }

    task.onCancel = function () {
      cancelAll(tasks);
    };
  };
}


// Often-used functionality
function delay(ms) {
  return function (task) {
    var timer = setTimeout(function () {
      task.success(undefined);
    }, ms);

    task.onCancel = function () {
      clearTimeout(timer);
    };
  };
}

function log(s) {
  return function (task) {
    console["log"](s);
    task.success(undefined);
  };
}

export { noop, Task_from_Promise, Promise_from_Task, print_error, make_error,
         run_root, success, error, never, _bind, _finally, on_error, execute,
         ignore, thread, thread_wait, thread_kill, concurrent, race, delay,
         log };
----

.Task.nu
[source]
----
(TYPE (Task Value))

(TYPE (Thread Value))

(TYPE Error)

(INTERFACE T
  (Error<- :: (-> T Error)))

(EXPORT { error
          never
          finally = _finally
          on-error = on_error
          execute
          ignore
          thread
          thread/wait = thread_wait
          thread/kill! = thread_kill
          concurrent
          race
          delay
          log }

  (FFI-IMPORT "Task"
    (make_error :: (-> String Error))

    (run_root :: (-> (Task Void) Void))

    (success :: (FORALL A
                  (-> A (Task A))))

    (error :: (FORALL A
                (-> Error (Task A))))

    (never :: (FORALL A
                (-> (Task A))))

    (_bind :: (FORALL A B
                (-> (Task A)
                    (-> A (Task B))
                    (Task B))))

    (_finally :: (FORALL A
                   (-> (Task A)
                       (Task Void)
                       (Task A))))

    (on_error :: (FORALL A
                   (-> (Task A)
                       (-> Error (Task A))
                       (Task A))))

    (execute :: (FORALL A
                  (-> (-> A) (Task A))))

    (ignore :: (FORALL A
                 (-> (Task A)
                     (Task Void))))

    (thread :: (FORALL A
                 (-> (Task A) (Thread A))))

    (thread_wait :: (FORALL A
                      (-> (Thread A) (Task A))))

    (thread_kill :: (FORALL A
                      (-> (Thread A) (Task Void))))

    (concurrent :: (FORALL A
                     (-> @(Task A) (List (Task A)))))

    (race :: (FORALL A
               (-> @(Task A) (Task A))))

    (delay :: (-> Integer (Task Void)))

    (log :: (-> String (Task Void))))

  # TODO is there a better way of handling this ?
  (MACRO
    (FFI-PROGRAM-START)
      `(run_root (,(symbol "main"))))

  (IMPLEMENT String
    (Error<- x)
      (make_error x))

  (IMPLEMENT Task
    (wrap x)
      (success x)

    (bind x f)
      (_bind x f)))

(FUNCTION
  (forever :: (FORALL A
                (-> (Task Void) (Task A))))
  (forever task)
    (DO task
        (forever task)))

(FUNCTION
  (timeout :: (FORALL A
                (-> Integer (Task Void) (Task Void))))
  (timeout ms task)
    (race task (delay ms)))
----
