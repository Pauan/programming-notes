.Task.js
[source,javascript]
----
class Task {
  constructor() {
    // 0 is pending
    // 1 is succeeded
    // 2 is errored
    // 3 is cancelled
    this._state = 0;
    this._value = null;
    this._onsuccess = null;
    this._onerror = null;
    this._oncancel = null;
  }

  bind(success, error, cancel) {
    switch (this._state) {
    case 0:
      this._onsuccess = success;
      this._onerror = error;
      this._oncancel = cancel;
      break;

    case 1:
      return success(this._value);

    case 2:
      return error(this._value);

    case 3:
      return cancel();
    }
  }

  success(value) {
    if (this._state === 0) {
      var f = this._onsuccess;
      this._state = 1;
      this._value = value;
      this._onsuccess = null;
      this._onerror = null;
      this._oncancel = null;
      return f(value);
    }
  }

  error(e) {
    if (this._state === 0) {
      var f = this._onerror;
      this._state = 2;
      this._value = e;
      this._onsuccess = null;
      this._onerror = null;
      this._oncancel = null;
      return f(e);
    }
  }

  cancel() {
    if (this._state === 0) {
      var f = this._oncancel;
      this._state = 3;
      this._onsuccess = null;
      this._onerror = null;
      this._oncancel = null;
      return f();
    }
  }
}


export function noop() {}

export function task(f) {
  return function () {
    var out = new Task();

    try {
      f(out);
    } catch (e) {
      out.error(e);
    }

    return out;
  };
}

export function run(x) {
  return x();
}

export function print_error(e) {
  return console["error"](e["stack"]);
}

export function make_error(s) {
  return new Error(s);
}

export function run_root(task) {
  return run(task).bind(noop, print_error, noop);
}

// This can be implemented purely with `execute`,
// but it's faster to implement it like this
export function success(x) {
  return task(function (out) {
    return out.success(x);
  });
}

export function error(e) {
  return task(function (out) {
    return out.error(e);
  });
}

export function cancel() {
  return task(function (out) {
    return out.cancel();
  });
}

export function _bind(x, f) {
  return task(function (out) {
    function error(e) {
      return out.error(e);
    }

    function cancel() {
      return out.cancel();
    }

    return run(x).bind(function (value) {
      return run(f(value)).bind(function (value) {
        return out.success(value);
      }, error, cancel);
    }, error, cancel);
  });
}

export function _finally(before, after) {
  return task(function (out) {
    function error(e) {
      return out.error(e);
    }

    function cancel() {
      return out.cancel();
    }

    return run(before).bind(function (value) {
      return run(after).bind(function (_) {
        return out.success(value);
      }, error, cancel);

    }, function (e) {
      function propagate() {
        return out.error(e);
      }

      // Errors have precedence over cancellations
      return run(after).bind(propagate, error, propagate);

    }, cancel);
  });
}

export function on_error(x, f) {
  return task(function (out) {
    function success(value) {
      return out.success(value);
    }

    function cancel() {
      return out.cancel();
    }

    return run(x).bind(success, function (e) {
      return run(f(e)).bind(success, function (e) {
        return out.error(e);
      }, cancel);
    }, cancel);
  });
}

export function on_cancel(x, then) {
  return task(function (out) {
    function success(value) {
      return out.success(value);
    }

    function error(e) {
      return out.error(e);
    }

    return run(x).bind(success, error, function () {
      return run(then).bind(success, error, function () {
        return out.cancel();
      });
    });
  });
}

export function execute(f) {
  return task(function (out) {
    return out.success(f());
  });
}

// This can be implemented purely with bind + wrap,
// but it's more efficient to implement it with the FFI
export function ignore(x) {
  return task(function (out) {
    return run(x).bind(function (_) {
      return out.success(undefined);

    }, function (e) {
      return out.error(e);

    }, function () {
      return out.cancel();
    });
  });
}

export function delay(ms) {
  return task(function (out) {
    return setTimeout(function () {
      return out.success(undefined);
    }, ms);
  });
}

export function never() {
  return task(function (_) {});
}

export function detached(x) {
  return task(function (out) {
    // TODO should this use nextTick or something ?
    var t = run(x);
    t.bind(noop, print_error, noop);
    return out.success(t);
  });
}

export function detached_error(x, e) {
  return task(function (out) {
    // TODO should this use nextTick or something ?
    x.error(e);
    return out.success(undefined);
  });
}

export function detached_cancel(x) {
  return task(function (out) {
    // TODO should this use nextTick or something ?
    x.cancel();
    return out.success(undefined);
  });
}

function cancelAll(tasks) {
  for (var i = 0; i < tasks.length; ++i) {
    tasks[i].cancel();
  }
}

export function concurrent(a) {
  return task(function (t) {
    var out = new Array(a["length"]);

    var pending = a["length"];

    var tasks = a.map(run);

    function onSuccess() {
      --pending;
      if (pending === 0) {
        return t.success(out);
      }
    }

    function onError(e) {
      cancelAll(tasks);
      return t.error(e);
    }

    function onCancel() {
      cancelAll(tasks);
      return t.cancel();
    }

    return tasks.forEach(function (x, i) {
      x.bind(function (value) {
        out[i] = value;
        return onSuccess();
      }, onError, onCancel);
    });
  });
};

export function race(a) {
  return task(function (t) {
    var tasks = a.map(run);

    function onSuccess(value) {
      cancelAll(tasks);
      return t.success(value);
    }

    function onError(e) {
      cancelAll(tasks);
      return t.error(e);
    }

    function onCancel() {
      cancelAll(tasks);
      return t.cancel();
    }

    return tasks.forEach(function (x) {
      x.bind(onSuccess, onError, onCancel);
    });
  });
};
----

.Task.nu
[source]
----
(TYPE (Task Value))

(TYPE Error)

(TYPE Detached)

(INTERFACE T
  (Error<- :: (-> T Error)))

(EXPORT { error = error
          cancel = cancel
          finally = _finally
          on-error = on_error
          on-cancel = on_cancel
          execute
          ignore
          delay
          never
          detached
          detached/error! = detached_error
          detached/cancel! = detached_cancel
          concurrent
          race }

  (FFI-IMPORT "Task"
    (run_root :: (-> (Task Void) Void))

    (success :: (FORALL A
                  (-> A (Task A))))

    (error :: (FORALL A
                (-> Error (Task A))))

    (make_error :: (-> String Error))

    (cancel :: (FORALL A
                 (-> (Task A))))

    (never :: (FORALL A
                (-> (Task A))))

    (_bind :: (FORALL A B
                (-> (Task A)
                    (-> A (Task B))
                    (Task B))))

    (_finally :: (FORALL A
                   (-> (Task A)
                       (Task Void)
                       (Task A))))

    (on_error :: (FORALL A
                   (-> (Task A)
                       (-> Error (Task A))
                       (Task A))))

    (on_cancel :: (FORALL A
                    (-> (Task A)
                        (Task A)
                        (Task A))))

    (execute :: (FORALL A
                  (-> (-> A) (Task A))))

    (ignore :: (FORALL A
                 (-> (Task A)
                     (Task Void))))

    (delay :: (-> Integer (Task Void)))

    (detached :: (-> (Task Void) Detached))

    (detached_error :: (-> Detached Error (Task Void)))

    (detached_cancel :: (-> Detached (Task Void)))

    (concurrent :: (FORALL A
                     (-> @(Task A) (List (Task A)))))

    (race :: (FORALL A
               (-> @(Task A) (Task A)))))

  # TODO is there a better way of handling this ?
  (MACRO
    (FFI-PROGRAM-START)
      `(run_root (,(symbol "main"))))

  (IMPLEMENT String
    (Error<- x)
      (make_error x))

  (IMPLEMENT Task
    (wrap x)
      (success x)

    (bind x f)
      (_bind x f)))

(FUNCTION
  (forever :: (FORALL A B
                (-> (Task A) (Task B))))
  (forever task)
    (DO task
        (forever task)))

(FUNCTION
  (timeout :: (FORALL A
                (-> Integer (Task Void) (Task Void))))
  (timeout ms task)
    (race task (delay ms)))
----
