[source]
----
(FLAG+ "require-annotations")


(TYPE (Tree Key Value)
  (*nil)
  (*tree { left = (Tree Key Value)
           right = (Tree Key Value)
           key = Key
           value = Value
           depth = Integer }))


(FUNCTION
  (depth :: (FORALL Key Value
              (-> (Tree Key Value) Integer)))

  (depth (*tree x))
    x.depth

  (depth (*nil))
    0)


(FUNCTION
  (left :: (FORALL Key Value
             (-> (Tree Key Value)
                 (Tree Key Value))))

  (left (*tree x))
    x.left

  (left (*nil))
    (fail))


(FUNCTION
  (right :: (FORALL Key Value
              (-> (Tree Key Value)
                  (Tree Key Value))))

  (right (*tree x))
    x.right

  (right (*nil))
    (fail))


(FUNCTION
  (set-left :: (FORALL Key Value
                 (-> (Tree Key Value)
                     (Tree Key Value)
                     (Tree Key Value))))

  (set-left (*tree x) l)
    (*tree { @x left = l })

  (set-left (*nil) _)
    (fail))


(FUNCTION
  (set-right :: (FORALL Key Value
                  (-> (Tree Key Value)
                      (Tree Key Value)
                      (Tree Key Value))))

  (set-right (*tree x) r)
    (*tree { @x right = r })

  (set-right (*nil) _)
    (fail))


(FUNCTION
  (set-children :: (FORALL Key Value
                     (-> (Tree Key Value)
                         (Tree Key Value)
                         (Tree Key Value)
                         (Tree Key Value))))

  (set-children (*tree x) l r)
    (*tree { @x left  = l
                right = r })

  (set-children (*nil) _ _)
    (fail))


(FUNCTION
  (balance :: (FORALL Key Value
                (-> (Tree Key Value)
                    (Tree Key Value)
                    (Tree Key Value)
                    (Tree Key Value))))

  (balance (*nil))
    (*nil)

  (balance node)
    (LET l = (left node)
         r = (right node)
         l-depth = (depth l)
         r-depth = (depth r)

      # Left side is deeper
      (IF (more? l-depth (add r-depth 1))
        (LET rl = (left r)
             ll = (left l)

          (IF (more? (depth rl)
                     (depth ll))

            (LET lrl = (left (right l))
                 rrl = (left (right r))

              # Left rotate -> Right rotate
              (set-children rl (set-right l lrl) (set-left node rrl)))

            # Right rotate
            (set-right l (set-left node rl))))

        # Right side is deeper
        (IF (more? r-depth (add l-depth 1))
          (LET lr = (right l)
               rr = (right r)

            (IF (more? (depth lr)
                       (depth rr))

              (LET llr = (right (left l))
                   rlr = (right (left r))

                # Right rotate -> Left rotate
                (set-children lr (set-right node llr) (set-left r rlr)))

              # Left rotate
              (set-left r (set-right node lr))))

          # No balancing needed
          node))))


(FUNCTION
  (concat :: (FORALL Key Value
               (-> (Tree Key Value)
                   (Tree Key Value)
                   (Tree Key Value))))

  (concat x (*nil))
    x

  (concat (*nil) y)
    y

  (concat x y)
    # TODO what if the depths are the same ?
    (IF (less? (depth x)
               (depth y))
      (balance (set-left  y (concat x (left y))))
      (balance (set-right x (concat (right x) y)))))
----
