.Stream.nu
[source]
----
(USE {} = "nulan:Task")

(TYPE (Stream a))

(EXPORT { stream
          peek
          pull! = pull }

  (FFI-IMPORT "FFI/Stream"
    (stream :: (-> (-> (-> a (Task Void))
                       (Task Void))
                   (Task (Stream a))))

    (peek :: (-> (Stream a) (Task a)))

    (pull :: (-> (Stream a) (Task a)))))


(FUNCTION
  (each! :: (-> (Stream a)
                (-> a (Task Void))
                (Task Void)))
  (each! in f)
    (ignore-cancel
      (forever
        (DO value = (pull! in)
            (f value)))))

(FUNCTION
  (merge! :: (-> @(Stream a) (Task (Stream a))))
  (merge! @in)
    (stream -> push!
      (ignore-concurrent
        @(map in -> in
           (each! in push!)))))

(FUNCTION
  (map! :: (-> (Stream a)
               (-> a b)
               (Task (Stream b))))
  (map! in f)
    (stream -> push!
      (each! in -> value
        (push! (f value)))))

(FUNCTION
  (foldl! :: (-> a
                 (Stream b)
                 (-> a b (Task a))
                 (Task a)))
  (foldl! init in f)
    (LOOP next
        | old = init
      (on-cancel
        (DO value = (pull! in)
            (f old value))
        next
        (wrap old))))

(FUNCTION
  (join! :: (-> (Stream a) (Task a)))
  (join! in)
    (foldl! (empty) in concat))

(FUNCTION
  # TODO this type signature is probably wrong
  (flatten! :: (-> (Stream a)
                   (Task (Stream b))))
  (flatten! in out)
    (stream -> push!
      (each! in -> value
        (ignore-sequential
          @(map value push!)))))
----

.Examples
[source]
----
(FUNCTION
  (generate-add :: (-> Integer (Task (Stream Integer))))
  (generate-add init)
    (stream -> push!
      (LOOP next
          | i = init
        (DO (push! i)
            (next (add i 1))))))

(FUNCTION
  (generate-multiply :: (-> Integer (Task (Stream Integer))))
  (generate-multiply init)
    (stream -> push!
      (LOOP next
          | i = init
        (DO (push! i)
            (next (multiply i 2))))))

(FUNCTION
  (accumulate :: (-> (Stream Integer) (Task Integer)))
  (accumulate in)
    (foldl! 0 in -> old value
      (LET new = (add old value)
        (DO (log new)
            (wrap new)))))


(DO # Lazily generates the stream [0 1 2 3 4 ...]
    x = (generate-add 0)

    # Lazily generates the stream [1 2 4 8 16 ...]
    y = (generate-multiply 1)

    # Merges the two streams in a non-deterministic fashion
    z = (merge! x y)

    # Accumulates and logs the sum of the merged stream
    (accumulate z))
----
