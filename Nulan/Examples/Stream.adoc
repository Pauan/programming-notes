.Stream.nu
[source]
----
(USE {} = "nulan:Task")

(TYPE (Stream A))

(EXPORT { stream
          stream/fixed = stream_fixed
          stream/sliding = stream_sliding
          stream/dropping = stream_dropping
          peek
          pull! = pull
          push! = push
          stream/close! = close }

  (FFI-IMPORT "Stream"
    (stream :: (FORALL A
                 (-> (Task (Stream A)))))

    (stream_fixed :: (FORALL A
                       (-> Integer (Task (Stream A)))))

    (stream_sliding :: (FORALL A
                         (-> Integer (Task (Stream A)))))

    (stream_dropping :: (FORALL A
                          (-> Integer (Task (Stream A)))))

    (peek :: (FORALL A
               (-> (Stream A) (Task A))))

    (pull :: (FORALL A
               (-> (Stream A) (Task A))))

    (push :: (FORALL A
               (-> (Stream A) A (Task Void))))

    (close :: (FORALL A
                (-> (Stream A) (Task Void))))))

(FUNCTION
  (w/in-stream :: (FORALL A
                    (-> (Task A)
                        (Task Void))))
  (w/in-stream task)
    (on-cancel
      (ignore task)
      (wrap (void))))

(FUNCTION
  (w/out-stream :: (FORALL A B
                     (-> (Stream A)
                         (Task B)
                         (Task Void))))
  (w/out-stream out task)
    # TODO if out gets closed, this may call stream/close! twice
    # TODO what if it errors ?
    (finally (w/in-stream task)
             (stream/close! out)))

# TODO find a better name for this
(FUNCTION
  (stream/generate :: (FORALL A B
                        (-> (Stream A)
                            (-> (Stream A) (Task B))
                            (Task (Stream A)))))
  (stream/generate out f)
    (DO (ignore
          (thread
            (w/out-stream out
              (f out))))
        (wrap out)))

(FUNCTION
  (stream/each! :: (FORALL A
                     (-> (Stream A)
                         (-> A (Task Void))
                         (Task Void))))
  (stream/each! in f)
    (w/in-stream
      (forever
        (DO value = (pull! in)
            (f value)))))

(FUNCTION
  (pipe! :: (FORALL A
              (-> (Stream A)
                  (Stream A)
                  (Task Void))))
  (pipe! from to)
    (w/out-stream to
      (stream/each! from -> value
        (push! to value))))

(FUNCTION
  (stream/merge! :: (FORALL A
                      (-> @(Stream A)
                         (Stream A)
                         (Task Void))))
  (stream/merge! @in out)
    (w/out-stream out
      (concurrent
        @(map in -> in
           # Can't use pipe because we want to close the output stream
           # only when *all* of the input streams are closed
           (stream/each! in -> value
             (push! out value))))))

(FUNCTION
  (stream/map! :: (FORALL A B
                    (-> (Stream A)
                        (Stream B)
                        (-> A B)
                        (Task Void))))
  (stream/map! in out f)
    (w/stream out
      (stream/each! in -> value
        (push! out (f value)))))

(FUNCTION
  (stream/foldl! :: (FORALL A B
                      (-> A
                          (Stream B)
                          (-> A B (Task A))
                          (Task A))))
  (stream/foldl! init in f)
    (LOOP next
        | old = init
      # TODO doesn't this generate a huge chain of `on-cancel`s ?
      (on-cancel
        # TODO even though this is tail-recursive, does it generate a huge chain of `_bind` ?
        (DO value = (pull! in)
            new = (f old value)
            (next new))
        (wrap old))))

(FUNCTION
  (stream/join! :: (FORALL A
                     (-> (Stream A) (Task A))))
  (stream/join! in)
    (stream/foldl! (empty) in -> old value
      (concat old value)))

(FUNCTION
  # TODO this type signature is probably wrong
  (stream/flatten! :: (FORALL A B
                        (-> (Stream (A B))
                            (Stream B)
                            (Task Void))))
  (stream/flatten! in out)
    (w/out-stream out
      (stream/each! in -> value
        (ignore
          (sequence
            @(map value -> value
               (push! value out)))))))
----

.Examples
[source]
----
(FUNCTION
  (generate/add! :: (-> (Stream Integer) (Task Void)))
  (generate/add! out)
    (LOOP next
        | i = 0
      (DO (push! out i)
          (next (add i 1)))))

(FUNCTION
  (generate/multiply! :: (-> (Stream Integer) (Task Void)))
  (generate/multiply! out)
    (LOOP next
        | i = 1
      (DO (push! out i)
          (next (multiply i 2)))))

(FUNCTION
  (accumulate :: (-> (Stream Integer) (Task Integer)))
  (accumulate in)
    (stream/foldl! 0 in -> old value
      (LET new = (add old value)
        (DO (log new)
            (wrap new)))))


# Using threads
(DO # Lazily generates the stream [0 1 2 3 4 ...]
    x = (stream/generate (stream) generate-add!)

    # Lazily generates the stream [1 2 4 8 16 ...]
    y = (stream/generate (stream) generate/multiply!)

    # Merges the two streams in a non-deterministic fashion
    z = (stream/generate (stream) -> out
          (stream/merge! x y out))

    # Accumulates and logs the sum of the merged stream
    (ignore
      (accumulate z)))


# Using concurrent
(DO x = (stream)
    y = (stream)
    z = (stream)

    (ignore
      (concurrent
        # Lazily generates the stream [0 1 2 3 4 ...]
        (generate-add! x)

        # Lazily generates the stream [1 2 4 8 16 ...]
        (generate-multiply! y)

        # Merges the two streams in a non-deterministic fashion
        (stream/merge! x y z)

        # Accumulates and logs the sum of the merged stream
        (accumulate z))))


# Using a single Stream
(DO x = (stream)
  (ignore
    (concurrent
      # Lazily generates the stream [0 1 2 3 4 ...]
      (generate-add! x)

      # Lazily generates the stream [1 2 4 8 16 ...]
      (generate-multiply! x)

      # Accumulates and logs the sum of the merged stream
      (accumulate x))))
----
