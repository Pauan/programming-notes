.Stream.js
[source,javascript]
----
function check_length(task, i) {
  // TODO should we allow for a buffer of size 0 ?
  if (i >= 1) {
    return true;
  } else {
    task.error(new Error("Expected 1 or greater but got " + i));
    return false;
  }
}

function error(task) {
  task.error(this._error);
}

function error_pull(task) {
  task.error(new Error("Cannot pull: stream is closed"));
}

function error_push(task) {
  task.error(new Error("Cannot push: stream is closed"));
}

function error_error(task) {
  task.error(new Error("Cannot error: stream is closed"));
}

function error_close(task) {
  task.error(new Error("Cannot close: stream is already closed"));
}


class StreamBase {
  constructor() {
    this._error = null;
    this._pullers = [];
  }

  cleanup() {
    this._pullers = null;
  }

  each(f) {
    for (var i = 0; i < this._pullers["length"]; ++i) {
      f(this._pullers[i]);
    }
  }

  error(task, err) {
    this.each(function (x) {
      x.error(err);
    });

    this.cleanup();
    this._error = err;

    this.pull = error;
    this.push = error;
    this.error = error;
    this.close = error;

    task.error(err);
  }

  close(task) {
    // TODO is this correct ?
    this.each(function (x) {
      x.cancel();
    });

    this.cleanup();

    this.pull = error_pull;
    this.push = error_push;
    this.error = error_error;
    this.close = error_close;

    task.success(undefined);
  }
}


class Stream extends StreamBase {
  constructor() {
    super();
    this._pushers = [];
  }

  cleanup() {
    super.cleanup();
    this._pushers = null;
  }

  each(f) {
    super.each(f);

    for (var i = 0; i < this._pushers["length"]; ++i) {
      f(this._pushers[i].task);
    }
  }

  pull(task) {
    if (this._pushers["length"]) {
      var f = this._pushers["shift"]();
      f.task.success(undefined);
      task.success(f.value);

    } else {
      this._pullers["push"](task);
    }
  }

  push(task, value) {
    if (this._pullers["length"]) {
      var f = this._pullers["shift"]();
      f.success(value);
      task.success(undefined);

    } else {
      this._pushers["push"]({
        task: task,
        value: value
      });
    }
  }
}


class StreamBuffered extends StreamBase {
  constructor(limit) {
    super();
    this._limit = limit;
    this._buffer = [];
  }

  cleanup() {
    super.cleanup();
    this._limit = null;
    this._buffer = null;
  }

  pull(task) {
    if (this._buffer["length"]) {
      task.success(this._buffer["shift"]());

    } else {
      this._pullers["push"](task);
    }
  }

  push(task, value) {
    // If there is a pending pull
    if (this._pullers["length"]) {
      this._pullers["shift"]().success(value);
      task.success(undefined);

    // If there is room in the buffer
    } else if (this._buffer["length"] < this._limit) {
      this._buffer["push"](value);
      task.success(undefined);

    // Buffer is full
    } else {
      this.full(task, value);
    }
  }
}


class StreamFixed extends StreamBuffered {
  constructor(limit) {
    super(limit);
    this._pushers = [];
  }

  // TODO code duplication with Stream
  cleanup() {
    super.cleanup();
    this._pushers = null;
  }

  // TODO code duplication with Stream
  each(f) {
    super.each(f);

    for (var i = 0; i < this._pushers["length"]; ++i) {
      f(this._pushers[i].task);
    }
  }

  pull(task) {
    // If there is stuff in the buffer
    if (this._buffer["length"]) {
      var value = this._buffer["shift"]();

      // If there is a pending push
      if (this._pushers["length"]) {
        var f = this._pushers["shift"]();
        this._buffer["push"](f.value);
        f.task.success(undefined);
      }

      task.success(value);

    // Buffer is empty, wait for push
    } else {
      this._pullers["push"](task);
    }
  }

  full(task, value) {
    this._pushers["push"]({
      task: task,
      value: value
    });
  }
}


class StreamSliding extends StreamBuffered {
  full(task, value) {
    // TODO more efficient function for this
    this._buffer["shift"]();
    this._buffer["push"](value);
    task.success(undefined);
  }
}


class StreamDropping extends StreamBuffered {
  full(task, value) {
    task.success(undefined);
  }
}


export function stream() {
  return function (task) {
    task.success(new Stream());
  };
}

export function stream_fixed(i) {
  return function (task) {
    if (check_length(task, i)) {
      task.success(new StreamFixed(i));
    }
  };
}

export function stream_sliding(i) {
  return function (task) {
    if (check_length(task, i)) {
      task.success(new StreamSliding(i));
    }
  };
}

export function stream_dropping(i) {
  return function (task) {
    if (check_length(task, i)) {
      task.success(new StreamDropping(i));
    }
  };
}

export function pull(stream) {
  return function (task) {
    stream.pull(task);
  };
}

export function push(stream, value) {
  return function (task) {
    stream.push(task, value);
  };
}

export function error(stream, err) {
  return function (task) {
    stream.error(task, err);
  };
}

export function close(stream) {
  return function (task) {
    stream.close(task);
  };
}
----

.Stream.nu
[source]
----
(TYPE (Stream A))

(EXPORT { stream
          stream/fixed = stream_fixed
          stream/sliding = stream_sliding
          stream/dropping = stream_dropping
          pull! = pull
          push! = push
          stream/error! = error
          stream/close! = close }

  (FFI-IMPORT "Stream"
    (stream :: (FORALL A
                 (-> (Task (Stream A)))))

    (stream_fixed :: (FORALL A
                       (-> Integer (Task (Stream A)))))

    (stream_sliding :: (FORALL A
                         (-> Integer (Task (Stream A)))))

    (stream_dropping :: (FORALL A
                          (-> Integer (Task (Stream A)))))

    (pull :: (FORALL A
               (-> (Stream A) (Task A))))

    (push :: (FORALL A
               (-> (Stream A) A (Task Void))))

    (error :: (FORALL A
                (-> (Stream A) Error (Task Void))))

    (close :: (FORALL A
                (-> (Stream A) (Task Void))))))

(FUNCTION
  (stream/make :: (FORALL A B
                    (-> (-> (Stream A) (Task B))
                        (Task (Stream A)))))
  (stream/make f)
    (DO out = (stream)
        (thread (f out))
        (wrap out)))

(FUNCTION
  (stream/merge :: (FORALL A
                     (-> @(Stream A) (Task (Stream A)))))
  (stream/merge @in)
    (stream/make -> out
      (concurrent
        @(map in -> in
           (forever
             (DO value = (pull! in)
                 (push! out value)))))))

(FUNCTION
  (stream/map :: (FORALL A B
                   (-> (Stream A)
                       (-> A B)
                       (Task (Stream B)))))
  (stream/map in f)
    (stream/make -> out
      (forever
        (DO value = (pull! in)
            (push! out (f value))))))

(FUNCTION
  (stream/foldl :: (FORALL A B
                     (-> A
                         (Stream B)
                         (-> A B (Task A))
                         (Task Void))))
  (stream/foldl init s f)
    (LOOP next
        | old = init
      (DO value = (pull! s)
          new = (f old value)
          (next new))))
----

.Examples
[source]
----
(DO # Lazily generates the stream [0 1 2 3 4 ...]
    x = (stream/make -> out
          (LOOP next
              | i = 0
            (DO (push! out i)
                (next (add i 1)))))

    # Lazily generates the stream [1 2 4 8 16 ....]
    y = (stream/make -> out
          (LOOP next
              | i = 1
            (DO (push! out i)
                (next (multiply i 2)))))

    # Merges the two streams in a non-deterministic fashion
    z = (stream/merge x y)

    # Accumulates and logs the sum of the merged stream
    (stream/foldl 0 z -> old value
      (LET new = (add old value)
        (DO (log new)
            (wrap new)))))
----
